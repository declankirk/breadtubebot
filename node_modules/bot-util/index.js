let FB = require('fb');
let fs = require('fs');
const request = require('request');
const crypto = require('crypto');
let xtend = require('xtend');
let isUrl = require('is-url');
let fbVideoUpload = require('facebook-api-video-upload');
let schedule = require('node-schedule');
let months = ['january', 'february', 'march', 'april', 'may', 'june', 'july', 'august', 'september', 'october', 'november', 'december'];

//stolen from fb-id because that package had vulnerabilities, sorry fam
getId = function(pageUrl, cb) {
  request({
    url: pageUrl,
    timeout: 60000,
    jar: request.jar(),
    headers: {
      'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_8_3) AppleWebKit/537.31 (KHTML, like Gecko) Chrome/26.0.1410.65 Safari/537.31'
    }
  }, function (error, response, body) {
    if (!error && response.statusCode == 200) {
      var fileName = crypto.createHash('md5').update(pageUrl).digest('hex') + '.log';
      fs.writeFile(fileName, body, function(err) {
        if (err) {
          console.log(err);
        }
        else{
          var regularExpresionMatch = /fb:\/\/(group|page|profile)\/(\d{1,})/gi;
          var regularExpresionReplace = /fb:\/\/(group|page|profile)\//gi;
          var matchArray = body.match(regularExpresionMatch);
          
          if (matchArray && matchArray.length > 0) {
            cb(matchArray[0].replace(regularExpresionReplace, ''));
          }
          else {
            cb(0);
          }
          process.env.DEBUG && console.log(matchArray);

          // remove file
          fs.unlinkSync(fileName)
        }
      });
    }
    else {
      cb(0);
    }
  });
};


function isFunction(functionToCheck) {
    return functionToCheck && {}.toString.call(functionToCheck) === '[object Function]';
}


let getAll = function(t, id, f, cb = () => {}, res = null, arr = []) {
    let af = '';
    if(res && res.paging && res.paging.next){
        let next  = res.paging.next.match(/after=(.*)/)[0];
        af = '&' + next;
    }
    FB.api(`${id}/${t}?limit=100${af}${f}`, (res, err)=>{
        if(err){
            return;
        }
        else{
            if(!res.data.length && !arr.length) {
                cb(arr);
                return;
            }
            if(af.length == 0 && arr.length > 1){
                cb(arr);
                return;
            }
            else {
                if(!arr.length) arr = res.data;
                else arr = arr.concat(res.data);
                if(res.paging.cursors.before == res.paging.cursors.after && res.paging.cursors != undefined) cb(arr);
                else getAll(t, id, f, cb, res, arr);
            }
        }
    })
}

let getLatestN = function(t, id, n, f, cb = () => {}, res = null, arr2 = [], arr = []) {
    let af = '';
    if(res && res.paging && res.paging.next){
        let next  = res.paging.next.match(/after=(.*)/)[0];
        af = '&' + next;
    }
    if(!arr.length) {
        while(n) {
            if(n > 100) {
                arr.push(100);
                n -= 100;
            } else {
                arr.push(n%100);
                n -= n%100;
            }
        }
    }
    FB.api(`${id}/${t}?limit=${arr[0]}${af}${f}`, (res, err)=>{
        if(err){
            return;
        }
        else{
            if(af.length == 0 && arr2.length > 1){
                cb(arr2);
            }
            else {
                if(!arr2.length) arr2 = res.data;
                else arr2 = arr2.concat(res.data);
                arr = arr.splice(1);
                if(arr.length) getLatestN(t, id, n, f, cb, res, arr2, arr);
                else return cb(arr2);
            }
        }
    });
}
let getInDateRange = (t, id, d1, d2, f, cb = () => {}, res = null, arr = []) => {
    let since = `${d1.getDate()}+${months[d1.getMonth()]}+${d1.getFullYear()}`;
    let until = `${d2.getDate()}+${months[d2.getMonth()]}+${d2.getFullYear()}`;
    let af = '';
    if(res && res.paging && res.paging.next){
        let next  = res.paging.next.match(/after=(.*)/)[0];
        af = '&' + next;
    }
    FB.api(`${id}/${t}?limit=100&since=${since}&until=${until}${af}${f}`, (res, err)=>{
        if(err){
            return;
        }
        else{
            if(af.length == 0 && arr.length > 1){
                cb(arr);
            }
            else {
                if(!arr.length) arr = res.data;
                else arr = arr.concat(res.data);
                getInDateRange(t, id, d1, d2, f, cb, res, arr);
            }
        }
    });
}
/**
 * 
 * @param {(string|Object)} arg - string of fields separated by "," or array of fields
 * 
 */
let getFields = arg => {
    if(typeof arg == "string") {
        return `&fields=${arg.replace(/\s+/g, '')}`;
    } else if(typeof arg == "object"){
        arg.forEach((b,c) => arg[c] = b.replace(/\s+/g, ''));
        return `&fields=${arg.join()}`
    } else return '';
}

class Page {
    constructor(platform, id, accessToken, name){
        this.platform = platform;
        this.id = id;
        this.accessToken = accessToken;
        this.scheduledPosts = [];
        if(name.length) this.name = name;
        else this.name = 'page_' + Platforms[this.platform].pages.all.length;
        this.get = {
            reactions: (obj_id, opt) => {
                return new Promise((resolve, reject) => {
                    if(typeof obj_id == 'string' || typeof obj_id == 'number'){
                        FB.setAccessToken(this.accessToken);
                        let fields = (opt != undefined) ? getFields(opt.fields) : '';
                        getAll('reactions', obj_id, fields, reacts => {
                            resolve(reacts);
                        });
                    } else throw new Error(`Invalid or missing object ID in 'get.reactions'`);
                });
            },
            posts: {
                all: (opt) => {
                    return new Promise((resolve, reject)=>{
                        FB.setAccessToken(this.accessToken);
                        let fields = (opt != undefined) ? getFields(opt.fields) : '';
                        getAll('posts', this.id, fields, posts => {
                            resolve(posts);
                        });
                    });
                },
                latest: (n, opt) => {
                    return new Promise((resolve, reject)=>{
                        FB.setAccessToken(this.accessToken);
                        //n wasn't specified, only return the last post
                        if(!n) {
                            FB.api(`${this.id}/feed`, (res, err)=>{
                                if(err) reject(err);
                                else {
                                    resolve(res.data[0]);
                                }
                            });
                        } else {
                            if(typeof n == "number" || Number(n) > 0) {
                                let fields = (opt != undefined) ? getFields(opt.fields) : '';
                                getLatestN('posts', this.id, n, fields, posts => {
                                    resolve(posts);
                                });
                            }
                        }
                        
                    });
                },
                range: (d1, d2, opt) => {
                    return new Promise((resolve, reject) => {
                        FB.setAccessToken(this.accessToken);
                        let fields = (opt != undefined) ? getFields(opt.fields) : '';
                        getInDateRange('posts', this.id, d1, d2, fields, posts => {
                            resolve(posts);
                        });
                    });
                }
            },
            comments: (obj_id, opt) => {
                return new Promise((resolve, reject) => {
                    if(typeof obj_id == 'string' || typeof obj_id == 'number'){
                        FB.setAccessToken(this.accessToken);
                        let fields = (opt != undefined) ? getFields(opt.fields) : '';
                        getAll('comments', obj_id, fields, comments => {
                            resolve(comments);
                        });
                    } else throw new Error(`Invalid or missing object ID in 'get.comments'`);
                });
            }
        }
    }
    
    Comment(obj){
        return new Promise((resolve, reject) => {
            if(typeof obj.on == 'string' || typeof obj.on == 'number'){
                if(typeof obj.message != undefined && obj.message.length){
                    FB.setAccessToken(this.accessToken);
                    // COMMENT HAS AN IMAGE ATTACHMENT
                    if(typeof obj.source == 'string' || obj.source instanceof fs.ReadStream){
                        if(obj.source instanceof fs.ReadStream){
                            FB.api(`${obj.on}/comments`, 'post', { message: obj.message, source: obj.source }, res => {
                                if(!res || res.error){
                                    reject(!res ? 'error occurred' : res.error);
                                    return;
                                }
                                resolve(res);
                            });
                        }
                        else if (typeof obj.source == 'string'){
                            FB.api(`${obj.on}/comments`, 'post', { message: obj.message, source: fs.createReadStream(obj.source) }, res => {
                                if(!res || res.error){
                                    reject(!res ? 'error occurred' : res.error);
                                    return;
                                }
                                resolve(res);
                            });
                        }
                        else throw new Error('Invalid source for photo comment.')
                    }
                    // COMMENT IS TEXT ONLY
                    else {
                        FB.api(`${obj.on}/comments`, 'post', { message: obj.message }, res => {
                            if(!res || res.error){
                                reject(!res ? 'error occurred' : res.error);
                                return;
                            }
                            resolve(res);
                        });
                    }
                }
                else throw new Error(`'message' parameter missing or empty. The 'message' parameter must be 1 or more characters.`);
                
            }
            else throw new Error(`Missing parameter 'on' from comment.`);
        });
    }

    SchedulePost(scheduleRule, func){
        return new Promise((resolve, reject) => {
            if(isFunction(func)){
                let job = schedule.scheduleJob(scheduleRule, ()=>{
                    if(func() instanceof Promise){
                        func().then(o => {
                            this.Post(o).then(res => {
                                if(o.hasOwnProperty('onPosted')){
                                    o.onPosted(res);
                                }
                            }).catch(err => {
                                console.log(err);
                            });
                        });
                    }
                    else{
                        let obj = func();
                        this.Post(obj).then(res => {
                            if(obj.hasOwnProperty('onPosted')){
                                obj.onPosted(res);
                            }
                        }).catch(err => {
                            console.log(err);
                        });
                    }
                });
                this.scheduledPosts.push(job);
                resolve(job);
            }
        });
    }

    Post(obj){
        return new Promise((resolve, reject) => {
            if(typeof obj.type == 'string'){
                FB.setAccessToken(this.accessToken);
                switch(obj.type.toLowerCase()){
                    case "text":
                        if(typeof obj.description == 'string' || typeof obj.description == 'number') obj.message = obj.description.toString();
                        if(typeof obj.caption == 'string' || typeof obj.caption == 'number') obj.message = obj.caption.toString();
                        if(obj.message && (typeof obj.message == 'string' || typeof obj.message == 'number')){
                            FB.api(`${this.id}/feed`, 'post', { message: obj.message }, res => {
                                if(!res || res.error || res.error_user_title){
                                    reject(!res ? 'error occurred' : res.error);
                                    return;
                                }
                                if(typeof obj.comment == 'object'){
                                    obj.comment.on = res.id;
                                    this.Comment(obj.comment).then(comres => {
                                        res.comment_id = comres.id;
                                        resolve(res);
                                    });
                                }
                                else resolve(res);
                            })
                        }
                        else throw new Error(`Missing parameter 'message' from post.`);
                        break;
                    case "image":
                        obj = xtend({
                            caption: ''
                        }, obj);
                        if(typeof obj.message == 'string' || typeof obj.message == 'number') obj.caption = obj.message.toString();
                        if(typeof obj.description == 'string' || typeof obj.description == 'number') obj.caption = obj.description.toString();

                        if(obj.source instanceof fs.ReadStream){ 
                            FB.api(`${this.id}/photos`, 'post', {source: obj.source, caption: obj.caption}, res => {
                                if(!res || res.error || res.error_user_title){
                                    reject(!res ? 'error occurred' : res.error);
                                    return;
                                }
                                res.id = res.post_id;
                                if(typeof obj.comment == 'object'){
                                    obj.comment.on = res.id
                                    this.Comment(obj.comment).then(comres => {
                                        res.comment_id = comres.id;
                                        resolve(res);
                                    }).catch(error => {
                                        reject(error);
                                    });
                                }
                                else resolve(res);
                            });
                        }
                        else if(typeof obj.source == 'string'){
                            FB.api(`${this.id}/photos`, 'post', {source: fs.createReadStream(obj.source), caption: obj.caption}, res => {
                                if(!res || res.error || res.error_user_title){
                                    reject(!res ? 'error occurred' : res.error);
                                    return;
                                }
                                res.id = res.post_id;
                                if(typeof obj.comment == 'object'){
                                    obj.comment.on = res.id
                                    this.Comment(obj.comment).then(comres => {
                                        res.comment_id = comres.id;
                                        resolve(res);
                                    }).catch(error => {
                                        reject(error);
                                    });
                                }
                                else resolve(res);
                            });
                        }
                        else throw new Error('Invaid source. Must be a path or a ReadStream');
                        break;
                    case "video":
                        if(obj.source){
                            if(typeof obj.source == 'string')
                                obj.stream = fs.createReadStream(obj.source);
                            if(typeof obj.message == 'string' || typeof obj.message == 'number') obj.description = obj.message.toString();
                            if(typeof obj.caption == 'string' || typeof obj.caption == 'number') obj.description = obj.caption.toString();
                            obj = xtend({
                                token: this.accessToken,
                                id: this.id,
                                title: '',
                                description: ''
                            }, obj);
                            fbVideoUpload(obj).then(res => {
                                res.id = res.video_id;
                                if(typeof obj.comment == 'object'){
                                    obj.comment.on = res.id
                                    this.Comment(obj.comment).then(comres => {
                                        res.comment_id = comres.id;
                                        resolve(res);
                                    }).catch(error => {
                                        reject(error);
                                    });
                                }
                                else resolve(res);
                            }).catch(e => {
                                reject(e);
                            });
                        }
                        else throw new Error('Source undefined.')
                        break;
                }
            }
            else throw new Error('Type of post not specified');
        });
    }
}

let Platforms = {
    Facebook: {
        api: FB.api,
        pages: {
            all: []
        },
        AddPage: function(id, accessToken, name = ''){
            return new Promise((resolve, reject) => {
                if(typeof accessToken == 'string'){
                    if(typeof id == 'string' || typeof id == 'number'){
                        if(isUrl(id)){
                            getId(id, id=>{
                                let page = new Page('Facebook', id, accessToken, name);
                                this.pages.all.push(page);
                                this.pages[id.toString()] = page;
                                resolve(id);
                            });
                        } else {
                            let page = new Page('Facebook', id, accessToken, name);
                            this.pages.all.push(page);
                            this.pages[id.toString()] = page;
                            resolve(id);
                        }
                    }
                }
                else reject('Access token must be a string.');
            })
        },
        AddPages: arr => {
            if(Array.isArray(arr)){
                return new Promise((resolve, reject) => {
                    addPagesRecursively(arr, array => {
                        let ids = [];
                        for(let i = 0; i < array.length; i++){
                            ids.push(array[i].id);
                        }
                        resolve(ids);
                    });
                });
            }
        }
    },
    Discord: {

    }
}

function addPagesRecursively(arr, cb, i = 0) {
    if(arr[i]){
        let token = arr[i].accessToken || arr[i].token;
        let name = '';
        if(typeof arr[i].name == "string") name = arr[i].name;
        if(typeof arr[i].id == "string" || typeof arr[i].id == "number"){
            Platforms.Facebook.AddPage(arr[i].id, token, name).then(id => {
                addPagesRecursively(arr, cb, i + 1);
            });
        } else throw new Error("Invalid page ID");
    } else cb(arr);
}

module.exports = {
    facebook: Platforms.Facebook,
    schedule: schedule
}
